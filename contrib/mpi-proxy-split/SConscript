import os
import sys
import platform as _platform
env = Environment()
# env['platform'] = _platform.system().lower();

# === GET DEFAULT FROM ENVIRONMENT, CONFIGURE ===

Import("ENV")

# Choose values from top-level SConstruct, or else from default Environment.
# The top-level SConstruct will look in environment and combine w/ configure.
env["CC"] = ENV.get("CC") or env["CC"]
env["CXX"] = ENV.get("CXX") or env["CXX"]
env["ENV"].update(x for x in os.environ.items() if x[0].startswith("CCC_"))
env["PATH"] = ENV["PATH"]

# We could have alternatively used CPPPATH and _CPPINCFLAGS for the includes.
# Unlike Python, we need to put the rhs inside a list, since scons definews
#   its own objects for these..
# For .c files, this is all that is needed.
env["CPPPATH"] = "#/include lower-half".split()
env.Append(CFLAGS = "-std=gnu11")
env.Append(CXXFLAGS = "-std=c++11")
# For .cpp files, this is what is needed.
env["CPPPATH"] = "#/include #/jalib mpi-wrappers . #/src lower-half".split()

env.Append(CFLAGS = "-fno-omit-frame-pointer -O1 " +
                    "-fno-optimize-sibling-calls -Wall -g3 -O0 -DDEBUG")
env.Append(CXXFLAGS = "-fno-omit-frame-pointer -O1 " +
                      "-fno-optimize-sibling-calls -Wall -g3 -O0 -DDEBUG")

if ENV.get('HOST').startswith('cori'):
  env["ENV"] = os.environ # Pick up environment for Cori
  env["MPICC"] = "cc"
  env["MPICXX"] = "CC"
  env["MPI_LD_FLAG"] = "-lmpich"
  env["MPIRUN"] = "srun"
  if "MPI_CFLAGS" not in env:
    env["MPI_CFLAGS"] = "-g3 -O0 -std=c99 -fPIC"
  if "MPI_CXXFLAGS" not in env:
    env["MPI_CXXFLAGS"]  = "-g3 -O0 -std=c99 -fPIC"
  if "MPI_CXXFLAGS" not in env:
    env["MPI_CXXFLAGS"] = "-g3 -O0 -std=c99 -fPIC"
  if "MPI_LDFLAGS" not in env:
    env["MPI_LDFLAGS"] = "-dynamic"
  # This is needed, or else mana_coordinator.o becomes the default target.
  #default2: default
  ## On Cori at NERSC, MPICC is CC, which translates to icpc(ICC)-v19
  ## But this .o file will be linked with src/dmtcp_coordinator.o, which
  ##   is built with g++.  So, we use $(CXX) for compatibility.
  ## An alternative is to use -O2, which inlines calls to memcpy.

# ===== Communicate with subdirectory 'scons' ======

Export("env")

# Lower half
SConscript("lower-half/SConscript")

# MPI wrappers
# SConscript("mpi-wrappers/SConscript")

# Unit tests
SConscript("unit-test/SConscript")
SConscript("test/SConscript")
SConscript("test-ckpt-restart/SConscript")

## Extra
# SConscript("cppunit-installed/SConscript")
# SConscript("doc/SConscript")

print "===================================================="
print "Compiling base source files of mpi-proxy-split"
print "===================================================="

env["CXX"] = env["MPICXX"]

# LIBMANA_SOURCE = Glob('*.cpp')
LIBMANA_SOURCE = Split("""
  drain_send_recv_packets.cpp mpi_plugin.cpp split_process.cpp
  record-replay.cpp  two-phase-algo.cpp lower-half/procmapsutils.c
""")

# These are needed for libmana.so, since the wrapper functions there will
# call the lower half.  That requires temporarily changing the FS register,
# and apparently, glibc detects this as an attempt to do stack smashing.
env.Append(CFLAGS = "-fno-stack-protector")
env.Append(CXXFLAGS = "-fno-stack-protector")

# Build a shared library
env.SharedLibrary(target = "mana", source = LIBMANA_SOURCE)

# Build an object file for use in DMTCP_ROOT/src
if ENV.get('HOST').startswith('cori'):
  import subprocess
  envCoord = env.Clone(CXX = env["MPICXX"]) # DOES NOT CHANGE $CXX
  mpicxxCrayFlags = subprocess.Popen("CC --cray-print-opts=cflags".split(),
                       stdout=subprocess.PIPE).communicate()[0] 
  envCoord.Append(CXXFLAGS = mpicxxCrayFlags)
  envCoord.Command("mana_coordinator.o", "mana_coordinator.cpp",
                   "$CXX $CXXFLAGS $_CPPINCFLAGS -c -o $TARGET $SOURCE")
else:
  env.Object("mana_coordinator.o", "mana_coordinator.cpp")

# ===================== CONFIGURE  ===============================

"""
# FIXME: We should eventually dynamically choose this address in setLhMemRange.
#        Then, we won't need this configure variable.
MANA_USE_LH_FIXED_ADDRESS = @MANA_USE_LH_FIXED_ADDRESS@

CFLAGS = @CFLAGS@
CXXFLAGS = @CXXFLAGS@

ifeq ($(findstring cori,$(PLATFORM)),cori)
  MPICC = cc
  MPICXX = CC
  MPI_LD_FLAG = -lmpich
  MPIRUN = srun
  MPI_CFLAGS?= -g3 -O0 -std=c99 -fPIC
  MPI_CXXFLAGS?= -g3 -O0 -std=c99 -fPIC
  MPI_LDFLAGS?= -dynamic
# This is needed, or else mana_coordinator.o becomes the default target.
default2: default
## On Cori at NERSC, MPICC is CC, which translates to icpc(ICC)-v19
## But this .o file will be linked with src/dmtcp_coordinator.o, which
##   is built with g++.  So, we use $(CXX) for compatibility.
## An alternative is to use -O2, which inlines calls to memcpy.
mana_coordinator.o: mana_coordinator.cpp
	${CXX} ${CXXFLAGS} `CC --cray-print-opts=cflags` -c -o $@ $<
else
  MPI_BIN = @MPI_BIN@
  MPI_LIB = @MPI_LIB@
  MPI_INCLUDE = @MPI_INCLUDE@
  MPICC = @MPICC@
  MPICXX = @MPICXX@
  MPIRUN = @MPIRUN@
  MPI_LD_FLAG = @MPI_LD_FLAG@
  MPI_CFLAGS?= @MPI_CFLAGS@
  MPI_CXXFLAGS?= @MPI_CXXFLAGS@
  MPI_LDFLAGS?= @MPI_LDFLAGS@
endif

# If you trust your MPI distro package, this is another option:
#   MPICC = mpicc
#   MPICXX = mpic++
#   MPIRUN = mpirun
#   MPI_LD_FLAG = -lmpi
#   MPI_CFLAGS?= -g3 -O0 -std=c99 -fPIC
#   MPI_CXXFLAGS?= -g3 -O0 -std=c99 -fPIC
#   MPI_LDFLAGS?=
"""

# ===================== ORIGINAL ===============================

"""
# MPI compiler according to the platform
PLATFORM=${shell echo $$HOST}
include Makefile_config

# These are needed for libmana.so, since the wrapper functions there will
# call the lower half.  That requires temporarily changing the FS register,
# and apparently, glibc detects this as an attempt to do stack smashing.
override CFLAGS += -fno-stack-protector
override CXXFLAGS += -fno-stack-protector

ifeq (${MPICXX},)
  MPICXX = PLEASE_DEFINE_MPICXX
endif

ifeq (${MPICC},)
  MPICC = PLEASE_DEFINE_MPICC
endif

# Targets to install:
#   libmana.so (using mpi-wrappers/libmpiwrappers.a), lh_proxy, libmpidummy.so,
#   mana_coordinator.o (needed to compile dmtcp_coordinator)

# Subdirectories needed to install
LOWER_HALF_SRCDIR=lower-half
WRAPPERS_SRCDIR=mpi-wrappers

# Test subdirectory:
#   tests

# As you add new files to your plugin library, add the object file names here.

LIBOBJS = mpi_plugin.o drain_send_recv_packets.o \
          record-replay.o two-phase-algo.o \
          split_process.o ${LOWER_HALF_SRCDIR}/procmapsutils.o

MANA_COORD_OBJS = mana_coordinator.o

LIBPROXY = libproxy.a

# Modify if your DMTCP_ROOT is located elsewhere.
ifndef DMTCP_ROOT
  DMTCP_ROOT=../..
endif
DMTCP_INCLUDE=${DMTCP_ROOT}/include
JALIB_INCLUDE=${DMTCP_ROOT}/jalib

override CFLAGS += -fPIC -I${DMTCP_INCLUDE} -I${LOWER_HALF_SRCDIR} -std=gnu11
override CXXFLAGS += -fPIC -I${DMTCP_INCLUDE} -I${JALIB_INCLUDE} \
                     -I${WRAPPERS_SRCDIR} -I. \
                     -I${DMTCP_ROOT}/src -I${LOWER_HALF_SRCDIR} -std=c++11

# ${WRAPPERS_SRCDIR}/libmpiwrappers.a ia a prerequisite for libmana.so
# Always do 'make default' or 'make install' -- not 'make libmana.so'
default: ${MANA_COORD_OBJS}
	make -C ${WRAPPERS_SRCDIR} libmpiwrappers.a
	@make libmana.so
	@make -C ${LOWER_HALF_SRCDIR} lh_proxy
	@make -C ${WRAPPERS_SRCDIR} libmpidummy.so

# ${WRAPPERS_SRCDIR}/libmpiwrappers.a made in install/default before libmana.so
libmana.so: ${LIBOBJS} ${WRAPPERS_SRCDIR}/libmpiwrappers.a
	${CXX} -shared -fPIC -g3 -O0 -o $@ ${LIBOBJS} -Wl,--whole-archive ${WRAPPERS_SRCDIR}/libmpiwrappers.a -Wl,--no-whole-archive

mpi_unimplemented_wrappers.cpp: generate-mpi-unimplemented-wrappers.py mpi_unimplemented_wrappers.txt
	python $^ > $@

.c.o:
	${MPICC} ${CFLAGS} -c -o $@ $<

.cpp.o: virtual-ids.h
	${MPICXX} ${CXXFLAGS} -c -o $@ $<

${LOWER_HALF_SRCDIR}/procmapsutils.o: ${LOWER_HALF_SRCDIR}/procmapsutils.c
	@make -C ${LOWER_HALF_SRCDIR} procmapsutils.o

vi vim: ${FILE}
	vim $<

touch: ${FILE}
	$@ $<

gdb: ${basename lh_proxy.c ${FILE}}
	$@ $<

tests:
	@make -C test/ default

check: libmana.so ${LOWER_HALF_SRCDIR}/lh_proxy ./autotest.py
	@make -C test/ default
	@python ./autotest.py

check-unit: libmana.so
	@make -C unit-test/ check

${DMTCP_ROOT}/lib/dmtcp/libmana.so: libmana.so
	cp -f $< $@
${DMTCP_ROOT}/lib/dmtcp/libmpidummy.so:
	make -C ${WRAPPERS_SRCDIR} install
${DMTCP_ROOT}/bin/lh_proxy:
	make -C ${LOWER_HALF_SRCDIR} install

# ${WRAPPERS_SRCDIR}/libmpiwrappers.a ia a prerequisite for libmana.so,
#   which is a prerequisite for ${DMTCP_ROOT}/lib/dmtcp/libmana.so
# Always do 'make default' or 'make install' -- not 'make libmana.so'
# MANA_COORD_OBJS needed for 'make mana' at top level.
install: ${MANA_COORD_OBJS}
	make -C ${WRAPPERS_SRCDIR} libmpiwrappers.a
	make ${DMTCP_ROOT}/lib/dmtcp/libmana.so
	make ${DMTCP_ROOT}/lib/dmtcp/libmpidummy.so
	make ${DMTCP_ROOT}/bin/lh_proxy

tidy:
	rm -f *~ .*.swp dmtcp_restart_script*.sh ckpt_*.dmtcp
	rm -rf ckpt_rank_*

clean: tidy
	rm -f ${LIBOBJS} ${MANA_COORD_OBJS}
	rm -f libmana.so
	rm -f ${DMTCP_ROOT}/lib/dmtcp/libmana.so
	@cd ${LOWER_HALF_SRCDIR} && make clean
	@cd ${WRAPPERS_SRCDIR} && make clean

distclean: clean
	cd test && make clean
	cd unit-test && make clean

dist: distclean
	dir=`basename $$PWD` && cd .. && tar czvf $$dir.tgz ./$$dir
	dir=`basename $$PWD` && ls -l ../$$dir.tgz

.PHONY: default clean dist distclean vi vim touch gdb tidy check \
        tests check-unit install
"""
