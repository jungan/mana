import os
import sys
import platform as _platform
Import("env")
# env['platform'] = _platform.system().lower();
Import("ENV")

# === GET DEFAULT FROM ENVIRONMENT, FROM Makefile_config ===

if ENV.get('HOST').startswith('cori'):
  env["ENV"] = os.environ # Pick up environment for Cori
  env["MPICC"] = "cc"
  env["MPICXX"] = "CC"
  env["MPI_LD_FLAG"] = "-lmpich".split()
  env["MPIRUN"] = "srun"
  if "MPI_CFLAGS" not in env:
    env["MPI_CFLAGS"] = "-g3 -O0 -std=c99 -fPIC".split()
  if "MPI_CXXFLAGS" not in env:
    env["MPI_CXXFLAGS"]  = "-g3 -O0 -std=c99 -fPIC".split()
  if "MPI_CXXFLAGS" not in env:
    env["MPI_CXXFLAGS"] = "-g3 -O0 -std=c99 -fPIC".split()
  if "MPI_LDFLAGS" not in env:
    env["MPI_LDFLAGS"] = "-dynamic".split()
  # This is needed, or else mana_coordinator.o becomes the default target.
  #default2: default
  ## On Cori at NERSC, MPICC is CC, which translates to icpc(ICC)-v19
  ## But this .o file will be linked with src/dmtcp_coordinator.o, which
  ##   is built with g++.  So, we use $(CXX) for compatibility.
  ## An alternative is to use -O2, which inlines calls to memcpy.

Export("env")
env = env.Clone()  # Changes to 'env' after this are private to this SConscript

# Choose values from top-level SConstruct, or else from default Environment.
# The top-level SConstruct will look in environment and combine w/ configure.
## env["CC"] = ENV.get("CC") or env["CC"]
## env["CXX"] = ENV.get("CXX") or env["CXX"]
## env["ENV"].update(x for x in os.environ.items() if x[0].startswith("CCC_"))
## env["PATH"] = ENV["PATH"]

env["CPPPATH"] = "#/include lower-half".split()
env.Append(CFLAGS = "-std=gnu11")
env.Append(CXXFLAGS = "-std=c++11")
# These are the include directories:
env["CPPPATH"] = "#/include #/jalib mpi-wrappers . #/src lower-half".split()

# icpc+gcc-7.5.0 (built at NERSC): Fails at runtime on VASP during ('man mana')
env.Append(CFLAGS = Split("-fno-omit-frame-pointer -O1 " +
                          "-fno-optimize-sibling-calls -Wall -g3 -O0 -DDEBUG"))
env.Append(CXXFLAGS = Split("-fno-omit-frame-pointer -O1 " +
                          "-fno-optimize-sibling-calls -Wall -g3 -O0 -DDEBUG"))

# ===== Communicate with subdirectory 'scons' ======

# Lower half
SConscript("lower-half/SConscript")

# MPI wrappers
# SConscript("mpi-wrappers/SConscript")

# Unit tests
SConscript("unit-test/SConscript")
SConscript("test/SConscript")
SConscript("test-ckpt-restart/SConscript")

## Extra
# SConscript("cppunit-installed/SConscript")
# SConscript("doc/SConscript")

print "===================================================="
print "Compiling base source files of mpi-proxy-split"
print "===================================================="

env["CXX"] = env["MPICXX"]

# LIBMANA_SOURCE = Glob('*.cpp')
LIBMANA_SOURCE = Split("""
  drain_send_recv_packets.cpp mpi_plugin.cpp split_process.cpp
  record-replay.cpp  two-phase-algo.cpp lower-half/procmapsutils.c
""")

# These are needed for libmana.so, since the wrapper functions there will
# call the lower half.  That requires temporarily changing the FS register,
# and apparently, glibc detects this as an attempt to do stack smashing.
env.Append(CFLAGS = "-fno-stack-protector")
env.Append(CXXFLAGS = "-fno-stack-protector")

# Build a shared library
env.SharedLibrary(target = "mana", source = LIBMANA_SOURCE)

# Build an object file for use in DMTCP_ROOT/src
if ENV.get('HOST').startswith('cori'):
  import subprocess
  envCoord = env.Clone(CXX = env["MPICXX"]) # DOES NOT CHANGE $CXX
  mpicxxCrayFlags = subprocess.Popen("CC --cray-print-opts=cflags".split(),
                       stdout=subprocess.PIPE).communicate()[0] 
  envCoord.Append(CXXFLAGS = mpicxxCrayFlags)
  envCoord.Command("mana_coordinator.o", "mana_coordinator.cpp",
                   "$CXX $CXXFLAGS $_CPPINCFLAGS -c -o $TARGET $SOURCE")
else:
  env.Object("mana_coordinator.o", "mana_coordinator.cpp")
